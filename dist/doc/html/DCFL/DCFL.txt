-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Communication Free Learning-based constraint solver
--   
--   An implementation of Communication Free Learning, a technique used to
--   solve Constraint Satisfcation Problems (CSPs) in a parallelizable
--   manner. The algorithm is described in the paper Decentralized
--   Constraint Satisfaction by Duffy, et. al. and this implementation
--   provides both parallel and serial solvers.
@package DCFL
@version 0.1.5.0

module Data.DCFL

-- | Probability distribution; generally associated with a <a>Variable</a>.
data Distribution
Distribution :: [Double] -> Distribution
probab :: Distribution -> [Double]

-- | The integer values a <a>Variable</a> can take on.
data Values
Values :: [Integer] -> Values

-- | Each variable has a finite set of possible values, a value it holds at
--   a given point and a probability distribution over the set of possible
--   values.
data Variable
Variable :: [Int] -> Int -> Distribution -> Variable
possible :: Variable -> [Int]
valueIndex :: Variable -> Int
distr :: Variable -> Distribution

-- | Each constraint function ([Int] -&gt; Bool) is associated with a
--   certain set of variables. <a>ConstraintEl</a> represents this
--   relationship for a constraint function.
data ConstraintEl
ConstraintEl :: [Int] -> ([Int] -> Bool) -> ConstraintEl
variableIndices :: ConstraintEl -> [Int]
constraint :: ConstraintEl -> ([Int] -> Bool)

-- | Return value of <a>solve</a>.
data Solved
Solved :: [Variable] -> Int -> Solved
variables :: Solved -> [Variable]
iterationCount :: Solved -> Int

-- | Returns the number of finite values that a <a>Distribution</a> is
--   over.
width :: Num b => Distribution -> b

-- | Constant, as defined in the research paper "Decentralized Constraint
--   Satisfaction" Duffy, et al.
b :: Double

-- | Internally called function.
oneIfEqual :: (Num a1, Eq a) => a -> a -> a1
replicateDouble :: Int -> Double -> [Double]

-- | Initialize a distribution with each possible value having the same
--   probability. For example, initDistribution 5 gives <tt>
--   <a>Distribution</a> [0.2, 0.2, 0.2, 0.2, 0.2]. </tt>
initDistribution :: Int -> Distribution

-- | Adjust probability for the value which has just failed a constraint.
failureCurrProb :: t -> Double -> Double

-- | Adjust probability for values other than the one that just failed a
--   constraint.
failureOtherProb :: Double -> Double -> Double

-- | Adjust probability of taking on a value for a certain <a>Variable</a>
--   given that a constraint was just failed.
failureProb :: Eq a => Double -> a -> Double -> a -> Double

-- | Given a distribution, update it based on the value of success. If
--   successful, then set the probability of the current value to 1.0 and
--   the probability for every other value to 0.0. Otherwise, update it
--   with failureProb.
updateProb :: (Num a, Eq a, Enum a) => Distribution -> a -> Bool -> Distribution

-- | Same as <a>updateProb</a>, but rather than returning a
--   <a>Distribution</a>, this function returns a <a>Variable</a>.
updateVariableProb :: Variable -> Bool -> Variable

-- | Internal iteration function used by <a>cummDistribution</a>.
cummDistributionIter :: Distribution -> Int -> Double -> [Double]

-- | Creates a cummulative <a>Distribution</a> out of a given
--   <a>Distribution</a>.
cummDistribution :: Distribution -> Distribution

-- | Given a cummulative <a>Distribution</a>, this function returns the
--   where a random value should be "placed" within the
--   <a>Distribution</a>.
getValueIndex :: Distribution -> Double -> Int

-- | Returns a single random number between 0.0 and 1.0.
randomNum :: IO Double

-- | Randomize the value of a <a>Variable</a>.
randomizeVariable :: Variable -> IO Variable

-- | Evaluate one <a>constraint</a> with a list of <tt>values</tt>.
evalConstraint :: ([Int] -> Bool) -> [Int] -> Bool

-- | Evaluate the set constraint functions <tt>constraints</tt> with a list
--   of <tt>values</tt>.
evalConstraints :: [[Int] -> Bool] -> [Int] -> Bool

-- | Apply a function at only one index of a list. Internal function.
applyAt :: (Num b1, Eq b1, Enum b1) => (b -> b) -> b1 -> [b] -> [b]

-- | Get the <tt>Constraint</tt>s associated with a <a>Variable</a> of
--   index <tt>n</tt> in the list of <a>Variable</a>s.
getConstraintsFor :: Int -> [ConstraintEl] -> [[Int] -> Bool]

-- | Get the constraint functions out of a list of <a>ConstraintEl</a>s.
justConstraints :: [ConstraintEl] -> [[Int] -> Bool]

-- | Get a list of values from a list of <a>Variable</a>s.
getValues :: [Variable] -> [Int]

-- | Randomizes the value of a single <a>Variable</a> in a list of
--   <a>Variable</a>.
randomizeSingle :: Int -> [Variable] -> [IO Variable]

-- | Randomize all the variables in a list.
randomize :: [Variable] -> [IO Variable]

-- | Print variables.
printVariables :: Show a => [a] -> [IO ()]

-- | Either randomize or let a variable stay, depending on what the
--   constraint check tells us.
update :: Int -> [Variable] -> [ConstraintEl] -> IO [Variable]

-- | Update each variable in the indices list once. Internal function used
--   by updateEach.
updateEach' :: [Variable] -> [ConstraintEl] -> [Int] -> IO [Variable]

-- | Update each variable in the variable set based on the constraint set
--   value.
updateEach :: [Variable] -> [ConstraintEl] -> IO [Variable]

-- | Update the variable set <tt>n</tt> number of times.
updateEachTimes :: [Variable] -> [ConstraintEl] -> Int -> IO [Variable]

-- | Checks if every probability in the distribution is either 0 or 1. If
--   it is, then, all constraints have been satisfied.
checkDistrSolved :: Distribution -> Bool

-- | Check if the constraints have been solved by looking at the
--   distributions of each <a>Variable</a>.
checkSolved :: [Variable] -> Bool

-- | This is the moost important function within this library. Given a list
--   of <a>Variable</a> and a list of <a>ConstraintEl</a>, the library uses
--   the Communcation Free Learning Algorithm to return a <a>Solved</a>
--   value. Note that the implementation is not parallelized./
solve :: [Variable] -> [ConstraintEl] -> IO Solved
updateMapF :: [Variable] -> [ConstraintEl] -> Int -> IO Variable

-- | Updates each variable in the variable set a number of times and does
--   each variable's update in a separate thread.
updateEachThreaded :: Int -> [Variable] -> [ConstraintEl] -> IO [Variable]
updateEachTimesThreaded :: Int -> [Variable] -> [ConstraintEl] -> Int -> IO [Variable]

-- | Solve the constraint set in parallel using Haskell threads. In order
--   for the solution to be parallelized, the program using DCFL must be
--   compiled with GHC's '-threaded' option.
solveThreaded :: Int -> [Variable] -> [ConstraintEl] -> IO Solved
instance Show Distribution
instance Show Values
instance Show Variable
instance Show ConstraintEl
instance NFData Variable
instance NFData Distribution
